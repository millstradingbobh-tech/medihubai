<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />

  <title>Product chat</title>
  <style>
    :root {
  --primary: #2563eb;
  --bg: #f8fafc;
  --card: #ffffff;
  --border: #e5e7eb;
  --text: #0f172a;
  --muted: #64748b;
  --radius: 14px;
}

* {
  box-sizing: border-box;
}

body {
  margin: 0;
  background: var(--bg);
  font-family: system-ui, -apple-system, BlinkMacSystemFont, sans-serif;
  color: var(--text);
  display: flex;
  justify-content: center;
  padding: 24px;
}

.app {
  width: 100%;
  max-width: 900px;
  display: flex;
  flex-direction: column;
  gap: 20px;
}

h5 {
  margin: 0 0 10px;
}

hr {
  border: none;
  border-top: 1px solid var(--border);
  margin: 10px 0;
  clear: both;
}

.container {
  background: var(--card);
  border-radius: var(--radius);
  padding: 16px;
  display: flex;
  gap: 12px;
  align-items: center;
  box-shadow: 0 8px 20px rgba(0,0,0,0.04);
}

input[type="text"] {
  flex: 1;
  padding: 12px 14px;
  border-radius: 10px;
  border: 1px solid var(--border);
  font-size: 15px;
}

input[type="text"]:focus {
  outline: none;
  border-color: var(--primary);
}

button {
  padding: 12px 16px;
  border-radius: 10px;
  border: none;
  background: var(--primary);
  color: #fff;
  font-weight: 600;
  cursor: pointer;
  transition: transform 0.05s ease, opacity 0.15s ease;
}

button:hover {
  opacity: 0.9;
}

button:active {
  transform: scale(0.97);
}

#productPreQuestions > div {
  background: var(--card);
  border-radius: var(--radius);
  padding: 16px;
  box-shadow: 0 8px 20px rgba(0,0,0,0.04);
}

#productPreQuestions a {
  display: block;
  padding: 8px 0;
  color: var(--primary);
  text-decoration: none;
  font-weight: 500;
}

#productPreQuestions a:hover {
  text-decoration: underline;
}

#productChat .mdl-card {
  background: var(--card);
  border-radius: var(--radius);
  padding: 16px;
  box-shadow: 0 8px 20px rgba(0,0,0,0.04);
}

#productChat div[style*="text-align:right"] {
  background: #e0e7ff;
  padding: 10px 14px;
  border-radius: 12px 12px 4px 12px;
  margin-left: auto;
  margin-bottom: 10px;
  font-weight: 500;
  float:right;
  max-width: 70%;
  word-wrap: break-word;
}

#productChat div:not([style*="text-align:right"]) {
  background: #f1f5f9;
  padding: 10px 14px;
  border-radius: 12px 12px 12px 4px;
  margin-bottom: 10px;
  max-width: 70%;
  word-wrap: break-word;
}

#loading h5 {
  color: var(--muted);
  font-weight: 500;
}

#btn {
  align-self: flex-start;
  background: #16a34a;
}

#btn[disabled] {
  opacity: 0.6;
  cursor: not-allowed;
}

pre#log {
  background: #020617;
  color: #e5e7eb;
  border-radius: 12px;
  padding: 12px;
  max-height: 120px;
  overflow-y: auto;
  font-size: 13px;
  line-height: 1.4;
  display: none; /* hidden initially */
}

/* ==============================
   MOBILE / SMALL SCREEN UPDATES
   ============================== */

@media (max-width: 600px) {
  body {
    padding: 12px;
  }

  .container {
    flex-direction: column;
    align-items: stretch;
    gap: 10px;
    padding: 12px;
  }

  input[type="text"] {
    font-size: 18px;
    padding: 14px 16px;
  }

  button {
    width: 100%;
    padding: 14px 0;
    font-size: 17px;
    border-radius: 12px;
  }

  #productChat div[style*="text-align:right"],
  #productChat div:not([style*="text-align:right"]) {
    max-width: 100%;
    margin-left: 0 !important;
    float: none !important;
  }

  #btn {
    align-self: stretch;
  }

  #btn.recording {
    background: #dc2626; /* red */
  }

  #productPreQuestions > div {
    padding: 12px;
  }

  #productPreQuestions a {
    font-size: 16px;
  }

  pre#log {
    font-size: 14px;
    max-height: 180px;
  }
}

  </style>
</head>
<body>
<div class="app">

    <div class="container">
      <input type="text" id="productId" placeholder="Product ID or SKU" />
      <button onclick="findProduct()">Choose Product</button>
    </div>

    <div id="productPreQuestions"></div>

    <div id="loading"></div>
    <div id="productChat"></div>

    <hr />
  <div class="container">
      <input type="text" id="message" placeholder="Type your question..." />
      <button onclick="sendCustomChat()" id="sendMessage">Send Message</button>
      <button id="btn">Start Recording</button>
  </div>
    
  <pre id="log">Recording history:</pre>

</div>
<script>
  let randomString = getRandomSixDigitString();
  let skuOrId = '';
  let chatHistory = [];
  async function findProduct() {
    const productPreQuestions = document.getElementById('productPreQuestions');
    productPreQuestions.innerHTML = `<h5>Loading...</h5>`;
    skuOrId = document.getElementById('productId').value.trim();
    const regexOnlyDigits = /^\d+$/;

    try {
      const response = await fetch('/api/openai/generateProductQuestions', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({ productId: regexOnlyDigits.test(skuOrId) ? skuOrId : '', sessionId: randomString + '_' + skuOrId, locationName: 'Mills - Seven Hills', productSku: regexOnlyDigits.test(skuOrId) ? '' : skuOrId }),
      });

      if (!response.ok) {
        throw new Error('Network response was not ok');
      }

      const data = await response.json();
      productPreQuestions.innerHTML = `
        <div style="padding: 16px; width: 100%;">
          <h5>Pre-message for this product:</h5>
          <p><a href='#' onclick="preload(event, '${data[0]}')">${data[0]}</a></p>
          <p><a href='#' onclick="preload(event, '${data[1]}')">${data[1]}</a></p>
          <p><a href='#' onclick="preload(event, '${data[2]}')">${data[2]}</a></p>
        </div>
      `;
    } catch (error) {
      productPreQuestions.textContent = 'Error: ' + error.message;
    }
  }

  async function preload(event, preload) {
    event.preventDefault(); 
    console.log("Value passed:", preload);
    sendChat(preload);
  }

  async function sendCustomChat() {
    const customMessage = document.getElementById('message').value.trim();
    sendChat(customMessage);
  }

  function getRandomSixDigitString() {
    const randomNum = Math.floor(Math.random() * (999999 - 100000 + 1)) + 100000;
    return String(randomNum);
  }

  function formatText(text) {
    return text
      // **bold** â†’ <strong>bold</strong>
      .replace(/\*\*(.*?)\*\*/g, "<strong>$1</strong>")
      // \n â†’ <br>
      .replace(/\n/g, "<br>");
  }

  function convertChatHistory() {
    let response = '';
    for (const item of chatHistory) {
      response += `<div style="text-align:${item.direction === 'right'? 'right' : 'left'};">${item.text}</div><hr />`
    };
    const productChat = document.getElementById('productChat');
    productChat.innerHTML = `
      <div style="padding: 16px; width: 100%;">
        ${response}
      </div>
    `;
  }

  async function sendChat(message) {

    const productChat = document.getElementById('productChat');
    const loading = document.getElementById('loading');
    
    loading.innerHTML = `<h5>Loading...</h5>`;
  
    try {

        chatHistory.push({
          direction: 'right',
          text: message
        });
        const response = await fetch('/api/openai/chat', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
          },
          body: JSON.stringify({ productId: skuOrId, message: message, sessionId: randomString + '_' + skuOrId, locationName: 'Mills - Seven Hills' }),
        });

        if (!response.ok) {
          throw new Error('Network response was not ok');
        }

        const data = await response.json();
        chatHistory.push(
          {
            direction: 'left',
            text: formatText(data?.answer)
          }
        )
        convertChatHistory();

        loading.innerHTML = ``;
      } catch (error) {
        productChat.textContent = 'Error: ' + error.message;
      }
    }


  const btn = document.getElementById("btn");
  const logEl = document.getElementById("log");
  const sendMessageBtn = document.getElementById("sendMessage");

  let ws;
  let recorder;
  let stream;
  let filteredStream;
  let recording = false;

  // Silence detection
  let audioCtx, analyser, dataArray;
  let silenceStart = null;

  // Per-sentence buffering
  let sentenceChunks = [];

  const CALIBRATION_MS = 1500;
  const SPEECH_MARGIN_DB = 14;
  const NOISE_LEARN_RATE = 0.05;
  const GATE_HOLD_MS = 200;
  const MIN_SPEECH_MS = 120;
  const SILENCE_DURATION_MS = 1000;
  const MIN_BLOB_SIZE = 33000;

  let noiseFloorDb = -90;
  let calibrated = false;
  let calibrationStart = null;
  let gateOpen = false;
  let gateHoldUntil = 0;
  let speechStart = null;

  function log(msg) {
    logEl.textContent += `[${new Date().toLocaleTimeString()}] ${msg}\n`;
    logEl.scrollTop = logEl.scrollHeight;
  }

  btn.onclick = () => recording ? stopRecording() : startWS();

  /* =====================
     WebSocket
  ===================== */
  function startWS() {
    btn.disabled = true;

    const isLocalhost = ['localhost', '127.0.0.1'].includes(window.location.hostname);
    ws = new WebSocket(isLocalhost ?  `ws://localhost:8080/ws` : "wss://medihubai-476149103615.australia-southeast1.run.app/ws");
    ws.binaryType = "arraybuffer";

    ws.onopen = () => {
      log("WebSocket connected");
      ws.send(JSON.stringify({
        type: 'init',
        sku: skuOrId,
        sessionId: randomString + '_' + skuOrId,
        locationName: 'Mills - Seven Hills'
      }));
      startRecording();
      btn.classList.add("recording");
    };

    ws.onmessage = (e) => {
      try {
        const msg = JSON.parse(e.data);
        const productChat = document.getElementById('productChat');
        const loading = document.getElementById('loading');
        if (msg.type === "transcription") {
          log("You said: " + msg.text);
          chatHistory.pop();
          chatHistory.push({direction: 'right', text: msg.text});
          convertChatHistory();

          chatHistory.push(
            {
              direction: 'left',
              text: 'I am thinking...'
            }
          )
          convertChatHistory();
        }
        if (msg.type === "chatResponse") {
          log("We said: " + msg.text);
          
          const data = msg.text;
          chatHistory.pop();
          chatHistory.push({direction: 'left', text: formatText(data)});
          convertChatHistory();
          
          loading.innerHTML = ``;
        }
      } catch {}
    };

    ws.onerror = stopRecording;
    ws.onclose = stopRecording;
  }

  /* =====================
     Recording
  ===================== */
  async function startRecording() {
    stream = await navigator.mediaDevices.getUserMedia({
      audio: {
        echoCancellation: true,
        noiseSuppression: true,
        autoGainControl: true,
      },
    });

    audioCtx = new AudioContext();
    const source = audioCtx.createMediaStreamSource(stream);

    const highPass = audioCtx.createBiquadFilter();
    highPass.type = "highpass";
    highPass.frequency.value = 120;

    const lowPass = audioCtx.createBiquadFilter();
    lowPass.type = "lowpass";
    lowPass.frequency.value = 4000;

    const destination = audioCtx.createMediaStreamDestination();

    source.connect(highPass);
    highPass.connect(lowPass);
    lowPass.connect(destination);

    filteredStream = destination.stream;
    
    analyser = audioCtx.createAnalyser();
    analyser.fftSize = 2048;
    dataArray = new Float32Array(analyser.fftSize);
    source.connect(analyser);

    recording = true;
    btn.textContent = "Stop Recording";
    btn.disabled = false;

    // Disable Send Message button and show recording log
    sendMessageBtn.disabled = true;
    sendMessageBtn.style.opacity = "0.6";
    logEl.style.display = "block";

    startNewRecorder();
    detectSpeech();

    log("Recording started");
  }

  /* =====================
     MediaRecorder per sentence
  ===================== */
  function startNewRecorder() {
    sentenceChunks = [];

    recorder = new MediaRecorder(filteredStream, { mimeType: "audio/webm" });

    recorder.ondataavailable = e => {
      if (e.data.size > 0) {
        sentenceChunks.push(e.data);
      }
    };

    recorder.onstop = () => {
      const blob = new Blob(sentenceChunks, { type: "audio/webm" });

      if (blob.size >= MIN_BLOB_SIZE && ws?.readyState === WebSocket.OPEN) {
        chatHistory.push(
          {
            direction: 'right',
            text: 'I am analysing your voice...'
          }
        )
        convertChatHistory();
        ws.send(blob);
        log(`Sent speech (${Math.round(blob.size / 1024)} KB)`);
      }

      // Immediately start next sentence if still recording
      if (recording) {
        startNewRecorder();
      }
    };

    recorder.start();
  }

  /* =====================
     Speech Detection
  ===================== */
function detectSpeech() {
  if (!recording) return;

  analyser.getFloatTimeDomainData(dataArray);

  const now = performance.now();
  const len = dataArray.length;

  /* =====================
     RMS + dB
  ===================== */
  let sum = 0;
  for (let i = 0; i < len; i++) sum += dataArray[i] ** 2;
  const rms = Math.sqrt(sum / len);
  const db = 20 * Math.log10(rms || 1e-8);

  /* =====================
     ZCR (Zero Crossing Rate)
  ===================== */
  let zeroCrossings = 0;
  for (let i = 1; i < len; i++) {
    if ((dataArray[i - 1] >= 0) !== (dataArray[i] >= 0)) {
      zeroCrossings++;
    }
  }
  const zcr = zeroCrossings / len;

  /* =====================
     Calibration
  ===================== */
  if (!calibrated) {
    calibrationStart ??= now;
    noiseFloorDb += (db - noiseFloorDb) * 0.2;
    btn.textContent = "Calibrating silenceâ€¦";

    if (now - calibrationStart > CALIBRATION_MS) {
      calibrated = true;
      noiseFloorDb = Math.min(noiseFloorDb, -45);
      noiseFloorDb = Math.max(noiseFloorDb, -75);
      log(`Noise floor: ${noiseFloorDb.toFixed(1)} dB`);
    }

    requestAnimationFrame(detectSpeech);
    return;
  }

  /* =====================
     SPEECH DECISION
  ===================== */
  const thresholdDb = noiseFloorDb + SPEECH_MARGIN_DB;

  const isLoudEnough = db > thresholdDb;

  // Speech-like ZCR range (tuned)
  const isSpeechZCR = zcr > 0.01 && zcr < 0.2;

  // Combined decision
  const speechCandidate = isLoudEnough && isSpeechZCR;

  if (speechCandidate) {
    gateOpen = true;
    gateHoldUntil = now + GATE_HOLD_MS;
    speechStart ??= now;
  } else if (now > gateHoldUntil) {
    gateOpen = false;
    speechStart = null;
  }

  const speaking =
    gateOpen &&
    speechStart &&
    now - speechStart > MIN_SPEECH_MS;

  /* =====================
     Silence / Sentence Logic
  ===================== */
  if (!speaking) {
    silenceStart ??= Date.now();
    btn.textContent = "Listeningâ€¦";

    if (Date.now() - silenceStart > SILENCE_DURATION_MS) {
      silenceStart = null;
      cutSentence();
    }

    // Slowly adapt noise floor only when silent
    noiseFloorDb += (db - noiseFloorDb) * NOISE_LEARN_RATE;
  } else {
    btn.textContent = "ðŸŽ™ Speakingâ€¦";
    silenceStart = null;
  }

  requestAnimationFrame(detectSpeech);
}


  /* =====================
     Cut sentence (FINALIZE WEBM)
  ===================== */
  function cutSentence() {
    if (!recorder || recorder.state !== "recording") return;
    recorder.stop(); // ðŸ”‘ FINALIZES WEBM
  }

  /* =====================
     Stop everything
  ===================== */
  function stopRecording() {
    recording = false;
    btn.textContent = "Start Recording";
    btn.disabled = false;
    btn.classList.remove("recording");

    // Enable Send Message button again
    sendMessageBtn.disabled = false;
    sendMessageBtn.style.opacity = "1";

    if (recorder?.state === "recording") {
      recorder.stop();
    }

    stream?.getTracks().forEach(t => t.stop());
    audioCtx?.close();

    if (ws?.readyState === WebSocket.OPEN) {
      ws.send(JSON.stringify({ type: "stop" }));
      ws.close();
    }

    log("Recording stopped");
  }
</script>

</body>
</html>
